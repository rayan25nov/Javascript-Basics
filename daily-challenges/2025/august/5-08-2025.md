# Daily Challenge - August 5, 2025 🚀

**Topic**: Asynchronous JavaScript & API Simulation  
**Difficulty**: Medium  
**Estimated Time**: 60-75 minutes  
**Focus**: Promises, async/await, setTimeout, callback functions, and error handling

---

## 🎯 **Problem Statement**

You're building a **Food Delivery Tracking System** that simulates real-world asynchronous operations. This challenge focuses on JavaScript's asynchronous features - essential skills for handling API calls, timers, and concurrent operations in modern web applications!

### **Sample Data**

```javascript
const restaurants = [
  { id: 1, name: "Pizza Palace", preparationTime: 15, successRate: 0.9 },
  { id: 2, name: "Burger Barn", preparationTime: 10, successRate: 0.8 },
  { id: 3, name: "Sushi Spot", preparationTime: 20, successRate: 0.95 },
  { id: 4, name: "Taco Town", preparationTime: 8, successRate: 0.85 },
];

const deliveryDrivers = [
  { id: 1, name: "Alex", isAvailable: true, deliveryTime: 12 },
  { id: 2, name: "Sam", isAvailable: false, deliveryTime: 15 },
  { id: 3, name: "Jordan", isAvailable: true, deliveryTime: 10 },
  { id: 4, name: "Casey", isAvailable: true, deliveryTime: 18 },
];

const orders = [
  {
    id: 101,
    restaurantId: 1,
    items: ["Pizza Margherita", "Coke"],
    totalAmount: 15.99,
  },
  {
    id: 102,
    restaurantId: 2,
    items: ["Cheeseburger", "Fries"],
    totalAmount: 12.5,
  },
  {
    id: 103,
    restaurantId: 3,
    items: ["Salmon Roll", "Miso Soup"],
    totalAmount: 18.75,
  },
];
```

---

## 📋 **Tasks to Complete**

### **Task 1: Restaurant Order Processing** (25 points)

Create a function `processOrder(restaurantId, orderId)` that simulates restaurant food preparation using Promises.

**Requirements:**

- Use `setTimeout` to simulate preparation time
- Randomly succeed/fail based on restaurant's success rate
- Return a Promise that resolves with order status or rejects with error
- Include realistic preparation times from restaurant data

**Example:**

```javascript
processOrder(1, 101)
  .then((result) => console.log(result))
  .catch((error) => console.error(error));

// Expected output (after 15 seconds):
// { orderId: 101, status: "ready", preparationTime: 15, restaurant: "Pizza Palace" }
// OR (on failure):
// Error: "Order 101 failed during preparation at Pizza Palace"
```

### **Task 2: Driver Assignment System** (25 points)

Write an `async` function `assignDriver(orderId)` that finds and assigns an available driver.

**Requirements:**

- Check driver availability
- Assign the driver with shortest delivery time
- Mark driver as unavailable after assignment
- Handle case when no drivers are available
- Use async/await syntax

**Example:**

```javascript
const assignment = await assignDriver(101);
console.log(assignment);

// Expected output:
// { orderId: 101, driver: "Jordan", estimatedDeliveryTime: 10, assignedAt: "2025-08-05T10:30:00Z" }
```

### **Task 3: Parallel Order Processing** (25 points)

Create a function `processMultipleOrders(orderIds)` that processes multiple orders simultaneously.

**Requirements:**

- Use `Promise.all()` to process orders in parallel
- Handle partial failures (some orders succeed, others fail)
- Return results for all orders, including failed ones
- Calculate total processing time

**Example:**

```javascript
processMultipleOrders([101, 102, 103]).then((results) => console.log(results));

// Expected output:
// {
//   successful: [
//     { orderId: 101, status: "ready", restaurant: "Pizza Palace" },
//     { orderId: 103, status: "ready", restaurant: "Sushi Spot" }
//   ],
//   failed: [
//     { orderId: 102, error: "Order failed during preparation", restaurant: "Burger Barn" }
//   ],
//   totalProcessingTime: 20
// }
```

### **Task 4: Order Status Tracker** (15 points)

Build a function `trackOrderStatus(orderId)` that provides real-time order updates using callbacks.

**Requirements:**

- Simulate different order stages: "received", "preparing", "ready", "out for delivery", "delivered"
- Use callbacks to provide status updates
- Include timestamps for each status change
- Simulate realistic timing between stages

**Example:**

```javascript
trackOrderStatus(101, (status) => {
  console.log(
    `Order ${status.orderId}: ${status.stage} at ${status.timestamp}`
  );
});

// Expected output (over time):
// Order 101: received at 2025-08-05T10:00:00Z
// Order 101: preparing at 2025-08-05T10:01:00Z
// Order 101: ready at 2025-08-05T10:16:00Z
// Order 101: out for delivery at 2025-08-05T10:18:00Z
// Order 101: delivered at 2025-08-05T10:28:00Z
```

### **Task 5: Delivery Completion System** (10 points)

Create a function `completeDelivery(orderId, driverId)` that simulates delivery completion and makes drivers available again.

**Requirements:**

- Simulate delivery time using setTimeout
- Mark driver as available after delivery
- Return delivery confirmation
- Handle delivery failures (5% chance)

**Example:**

```javascript
completeDelivery(101, 1).then((confirmation) => console.log(confirmation));

// Expected output (after delivery time):
// { orderId: 101, driverId: 1, deliveredAt: "2025-08-05T10:28:00Z", status: "delivered" }
```

---

## 🎯 **Bonus Challenges** (+5 points each)

### **Bonus 1: Retry Mechanism**

Implement automatic retry for failed orders (max 3 attempts).

```javascript
processOrderWithRetry(restaurantId, orderId, (maxRetries = 3));
```

### **Bonus 2: Order Queue System**

Create a queue that processes orders sequentially when restaurants are busy.

```javascript
addToQueue(orderId); // Returns position in queue
processQueue(); // Processes next order in queue
```

### **Bonus 3: Delivery Time Prediction**

Calculate estimated delivery time based on current orders and driver availability.

```javascript
predictDeliveryTime(restaurantId); // Returns estimated minutes
```

---

## 💡 **JavaScript Concepts to Practice**

- **Promises**: Creating, resolving, rejecting promises
- **Async/Await**: Modern asynchronous syntax
- **Callbacks**: Traditional asynchronous patterns
- **Promise.all()**: Parallel promise execution
- **setTimeout**: Simulating delays and timers
- **Error Handling**: try/catch with async functions
- **Date/Time**: Working with timestamps

---

## 🚀 **Getting Started**

1. Create a new file: `daily-challenges/2025/august/day05-async-delivery.js`
2. Copy the sample data into your file
3. Implement each function step by step
4. Test your functions with the provided examples

### **Function Templates**

```javascript
// Sample Data
const restaurants = [
  { id: 1, name: "Pizza Palace", preparationTime: 15, successRate: 0.9 },
  { id: 2, name: "Burger Barn", preparationTime: 10, successRate: 0.8 },
  { id: 3, name: "Sushi Spot", preparationTime: 20, successRate: 0.95 },
  { id: 4, name: "Taco Town", preparationTime: 8, successRate: 0.85 },
];

const deliveryDrivers = [
  { id: 1, name: "Alex", isAvailable: true, deliveryTime: 12 },
  { id: 2, name: "Sam", isAvailable: false, deliveryTime: 15 },
  { id: 3, name: "Jordan", isAvailable: true, deliveryTime: 10 },
  { id: 4, name: "Casey", isAvailable: true, deliveryTime: 18 },
];

const orders = [
  {
    id: 101,
    restaurantId: 1,
    items: ["Pizza Margherita", "Coke"],
    totalAmount: 15.99,
  },
  {
    id: 102,
    restaurantId: 2,
    items: ["Cheeseburger", "Fries"],
    totalAmount: 12.5,
  },
  {
    id: 103,
    restaurantId: 3,
    items: ["Salmon Roll", "Miso Soup"],
    totalAmount: 18.75,
  },
];

// Task 1: Restaurant Order Processing
function processOrder(restaurantId, orderId) {
  return new Promise((resolve, reject) => {
    // Your implementation here
    // Hint: Use setTimeout, Math.random() for success rate

    const restaurant = restaurants.find((r) => r.id === restaurantId);
    if (!restaurant) {
      reject(new Error(`Restaurant ${restaurantId} not found`));
      return;
    }

    // Simulate preparation time and success/failure
    setTimeout(() => {
      // Your logic here
    }, restaurant.preparationTime * 1000); // Convert to milliseconds
  });
}

// Task 2: Driver Assignment System
async function assignDriver(orderId) {
  try {
    // Your implementation here
    // Hint: Filter available drivers, sort by delivery time

    const availableDrivers = deliveryDrivers.filter(
      (driver) => driver.isAvailable
    );

    if (availableDrivers.length === 0) {
      throw new Error("No drivers available");
    }

    // Find driver with shortest delivery time
    // Mark as unavailable
    // Return assignment details
  } catch (error) {
    throw error;
  }
}

// Task 3: Parallel Order Processing
function processMultipleOrders(orderIds) {
  // Your implementation here
  // Hint: Use Promise.allSettled() to handle partial failures

  const orderPromises = orderIds.map((orderId) => {
    // Find restaurant for each order
    // Process each order
    // Return promise
  });

  return Promise.allSettled(orderPromises).then((results) => {
    // Process results and separate successful/failed
    return {
      successful: [],
      failed: [],
      totalProcessingTime: 0,
    };
  });
}

// Task 4: Order Status Tracker
function trackOrderStatus(orderId, statusCallback) {
  // Your implementation here
  // Hint: Use multiple setTimeout calls for different stages

  const stages = [
    "received",
    "preparing",
    "ready",
    "out for delivery",
    "delivered",
  ];
  let currentStageIndex = 0;

  function updateStatus() {
    // Call statusCallback with current stage info
    // Set timeout for next stage
  }

  updateStatus(); // Start the process
}

// Task 5: Delivery Completion System
function completeDelivery(orderId, driverId) {
  return new Promise((resolve, reject) => {
    // Your implementation here
    // Hint: Find driver, simulate delivery time, mark as available

    const driver = deliveryDrivers.find((d) => d.id === driverId);

    setTimeout(() => {
      // 5% chance of delivery failure
      if (Math.random() < 0.05) {
        reject(new Error(`Delivery failed for order ${orderId}`));
      } else {
        // Mark driver as available
        // Resolve with delivery confirmation
      }
    }, driver.deliveryTime * 1000);
  });
}

// Test your functions
console.log("=== Task 1: Processing Order ===");
processOrder(1, 101)
  .then((result) => console.log("Order processed:", result))
  .catch((error) => console.error("Order failed:", error));

console.log("\n=== Task 2: Assigning Driver ===");
assignDriver(101)
  .then((assignment) => console.log("Driver assigned:", assignment))
  .catch((error) => console.error("Assignment failed:", error));

console.log("\n=== Task 3: Multiple Orders ===");
processMultipleOrders([101, 102, 103]).then((results) =>
  console.log("Batch results:", results)
);

console.log("\n=== Task 4: Order Tracking ===");
trackOrderStatus(101, (status) => {
  console.log(
    `📦 Order ${status.orderId}: ${status.stage} at ${status.timestamp}`
  );
});

console.log("\n=== Task 5: Delivery Completion ===");
completeDelivery(101, 1)
  .then((confirmation) => console.log("Delivered:", confirmation))
  .catch((error) => console.error("Delivery failed:", error));
```

---

## ✅ **Expected Behavior**

### **Task 1 - Success Case:**

```javascript
{ orderId: 101, status: "ready", preparationTime: 15, restaurant: "Pizza Palace" }
```

### **Task 2 - Driver Assignment:**

```javascript
{ orderId: 101, driver: "Jordan", estimatedDeliveryTime: 10, assignedAt: "2025-08-05T10:30:00Z" }
```

### **Task 4 - Status Updates:**

```javascript
// Real-time console outputs:
📦 Order 101: received at 2025-08-05T10:00:00Z
📦 Order 101: preparing at 2025-08-05T10:01:00Z
📦 Order 101: ready at 2025-08-05T10:16:00Z
📦 Order 101: out for delivery at 2025-08-05T10:18:00Z
📦 Order 101: delivered at 2025-08-05T10:28:00Z
```

---

## 🔍 **Hints**

<details>
<summary>Click to see hints if you're stuck</summary>

**Task 1**:

```javascript
// Use Math.random() < restaurant.successRate for success check
// setTimeout with restaurant.preparationTime * 1000 milliseconds
// resolve({ orderId, status: "ready", preparationTime, restaurant: restaurant.name })
```

**Task 2**:

```javascript
// availableDrivers.sort((a, b) => a.deliveryTime - b.deliveryTime)
// bestDriver = availableDrivers[0]
// bestDriver.isAvailable = false
```

**Task 3**:

```javascript
// Use Promise.allSettled() instead of Promise.all()
// Filter results by status: 'fulfilled' vs 'rejected'
// Math.max(...preparationTimes) for total time
```

**Task 4**:

```javascript
// Create array of timeouts: [0, 1000, 15000, 17000, 27000]
// Use setTimeout recursively or map through stages
// Include new Date().toISOString() for timestamps
```

**Task 5**:

```javascript
// Math.random() < 0.95 for success (95% success rate)
// driver.isAvailable = true after delivery
// Use deliveredAt: new Date().toISOString()
```

</details>

---

## 🎓 **Learning Objectives**

By completing this challenge, you will:

- ✅ Master Promise creation and handling
- ✅ Learn async/await syntax and patterns
- ✅ Practice parallel execution with Promise.all()
- ✅ Understand callback patterns and timing
- ✅ Build real-world asynchronous applications

---

## 📈 **Scoring**

- **Task 1**: 25 points (Promise-based order processing)
- **Task 2**: 25 points (Async/await driver assignment)
- **Task 3**: 25 points (Parallel processing)
- **Task 4**: 15 points (Callback-based tracking)
- **Task 5**: 10 points (Delivery completion)
- **Bonus**: +15 points possible

**Total Possible**: 115 points

---

## 🌟 **Success Criteria**

- ✅ Promises resolve/reject correctly with proper timing
- ✅ Async functions use proper error handling
- ✅ Parallel processing handles partial failures
- ✅ Callbacks provide timely status updates
- ✅ Code simulates realistic timing and scenarios

---

## 🔄 **Real-World Applications**

This challenge teaches skills used in:

- **API Integration**: Handling HTTP requests and responses
- **E-commerce**: Order processing and tracking systems
- **Real-time Updates**: WebSocket connections and live data
- **Background Tasks**: Queue processing and job scheduling
- **User Experience**: Loading states and progress indicators

---

**Happy Coding! 🎉**

_Today we're mastering asynchronous JavaScript - the key to building responsive, modern web applications that handle real-world timing and concurrency!_

---
