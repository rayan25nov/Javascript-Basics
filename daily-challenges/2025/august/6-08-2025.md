# Daily Challenge - August 6, 2025 🚀

**Topic**: Advanced JavaScript Concepts & Design Patterns  
**Difficulty**: Medium-Hard  
**Estimated Time**: 75-90 minutes  
**Focus**: Closures, prototypes, classes, modules, destructuring, spread/rest operators, and advanced function patterns

---

## 🎯 **Problem Statement**

You're building a **Advanced Task Management System** that demonstrates sophisticated JavaScript patterns and concepts. This challenge covers advanced JavaScript features that are essential for senior-level development - concepts often missed in basic tutorials but crucial for real-world applications!

### **Sample Data**

```javascript
const projectData = {
  teams: [
    {
      id: 1,
      name: "Frontend",
      members: ["Alice", "Bob", "Charlie"],
      budget: 50000,
    },
    {
      id: 2,
      name: "Backend",
      members: ["Diana", "Eve", "Frank"],
      budget: 75000,
    },
    { id: 3, name: "DevOps", members: ["Grace", "Henry"], budget: 40000 },
  ],
  tasks: [
    {
      id: 101,
      title: "Build Login Page",
      teamId: 1,
      priority: "high",
      estimatedHours: 16,
      tags: ["frontend", "auth"],
    },
    {
      id: 102,
      title: "API Development",
      teamId: 2,
      priority: "critical",
      estimatedHours: 32,
      tags: ["backend", "api"],
    },
    {
      id: 103,
      title: "Database Optimization",
      teamId: 2,
      priority: "medium",
      estimatedHours: 24,
      tags: ["database", "performance"],
    },
    {
      id: 104,
      title: "CI/CD Pipeline",
      teamId: 3,
      priority: "high",
      estimatedHours: 20,
      tags: ["devops", "automation"],
    },
  ],
  settings: {
    workingHoursPerDay: 8,
    overtimeMultiplier: 1.5,
    currencies: { USD: 1, EUR: 0.85, GBP: 0.73 },
    priorities: { low: 1, medium: 2, high: 3, critical: 4 },
  },
};
```

---

## 📋 **Tasks to Complete**

### **Task 1: Advanced Function Patterns** (20 points)

Create a **higher-order function factory** that generates specialized task filters with closures.

**Requirements:**

- Use closures to maintain private state
- Implement currying for flexible function composition
- Support method chaining
- Include memoization for performance

**Example:**

```javascript
const taskFilter = createTaskFilter(projectData.tasks);

// Curried functions with closures
const highPriorityTasks = taskFilter.byPriority("high").byTeam(1).execute();
const backendTasks = taskFilter
  .reset()
  .byTags(["backend"])
  .byEstimate(20, 40)
  .execute();

console.log(highPriorityTasks);
// Expected: Tasks that are high priority AND belong to team 1

// Chaining with memoization
const complexFilter = taskFilter
  .reset()
  .byPriority("critical", "high")
  .byEstimate(15)
  .cached() // Enable memoization
  .execute();
```

### **Task 2: Prototype-based Inheritance & Classes** (25 points)

Build a **class hierarchy** with prototypal inheritance, mixins, and advanced OOP patterns.

**Requirements:**

- Use both ES6 classes and prototype-based inheritance
- Implement mixins for shared functionality
- Use private fields and methods (# syntax)
- Include static methods and getters/setters
- Demonstrate method overriding and super calls

**Example:**

```javascript
// Base class with private fields
class ProjectEntity {
  #createdAt;
  #id;

  constructor(id) {
    this.#id = id;
    this.#createdAt = new Date();
  }

  get id() {
    return this.#id;
  }
  get age() {
    return Date.now() - this.#createdAt;
  }

  // Abstract method
  getDescription() {
    throw new Error("Must implement getDescription()");
  }
}

// Mixin for audit functionality
const AuditMixin = {
  logAction(action) {
    this.auditLog = this.auditLog || [];
    this.auditLog.push({ action, timestamp: Date.now() });
  },

  getAuditTrail() {
    return this.auditLog || [];
  },
};

// Task class extending base with mixin
class Task extends ProjectEntity {
  // Your implementation here
  // Should include private methods, static methods, etc.
}

// Team class with advanced features
class Team extends ProjectEntity {
  // Your implementation here
  // Should demonstrate inheritance, polymorphism
}

// Usage:
const task = new Task(101, "Build Login", 1);
task.assignMember("Alice");
task.updatePriority("high");
console.log(task.getDescription()); // Polymorphic call
console.log(task.getAuditTrail()); // From mixin
```

### **Task 3: Advanced Destructuring & Spread/Rest** (20 points)

Create functions that demonstrate complex destructuring patterns, spread/rest operators, and parameter handling.

**Requirements:**

- Deep destructuring with default values and renaming
- Rest parameters with destructuring
- Spread operator for object/array manipulation
- Dynamic property destructuring
- Function parameter destructuring with validation

**Example:**

```javascript
// Complex destructuring with defaults and renaming
function analyzeProject({
  teams: projectTeams = [],
  tasks: projectTasks = [],
  settings: {
    workingHoursPerDay: dailyHours = 8,
    priorities: priorityConfig = {},
    currencies: { USD: usdRate = 1, ...otherCurrencies } = {},
  } = {},
  ...additionalData
}) {
  // Your implementation here
  // Should handle complex nested destructuring
}

// Rest/spread patterns for team management
function mergeTeamData(baseTeam, ...updates) {
  // Your implementation here
  // Should use spread/rest for flexible merging
}

// Dynamic property extraction
function extractTaskFields(tasks, ...fieldNames) {
  // Your implementation here
  // Should dynamically extract specified fields
}

// Usage examples:
const analysis = analyzeProject(projectData);
const updatedTeam = mergeTeamData(
  { id: 1, name: "Frontend" },
  { budget: 60000 },
  { members: ["Alice", "Bob"] },
  { tools: ["React", "TypeScript"] }
);
```

### **Task 4: Module Pattern & Namespace Management** (20 points)

Implement a **module system** using IIFE, revealing module pattern, and ES6 modules simulation.

**Requirements:**

- Create private scope with IIFE
- Implement revealing module pattern
- Use WeakMap for truly private data
- Create namespace management system
- Include module loading and dependency injection

**Example:**

```javascript
// Revealing Module Pattern with private scope
const TaskManager = (function () {
  // Private variables using WeakMap
  const privateData = new WeakMap();

  // Private functions
  function validateTask(task) {
    // Your implementation
  }

  function calculateMetrics(tasks) {
    // Your implementation
  }

  // Public API
  return {
    createTask(taskData) {
      // Your implementation
    },

    getTaskMetrics() {
      // Your implementation
    },

    // Namespace for related functionality
    filters: {
      byPriority(priority) {
        /* implementation */
      },
      byTeam(teamId) {
        /* implementation */
      },
    },

    utils: {
      exportData() {
        /* implementation */
      },
      importData(data) {
        /* implementation */
      },
    },
  };
})();

// Usage:
const newTask = TaskManager.createTask({
  title: "New Feature",
  priority: "high",
});
const metrics = TaskManager.getTaskMetrics();
const filtered = TaskManager.filters.byPriority("critical");
```

### **Task 5: Advanced Array/Object Manipulation** (15 points)

Create sophisticated data transformation functions using advanced array methods and object manipulation.

**Requirements:**

- Use flatMap, reduce, and method chaining
- Implement group by and partition operations
- Create pipe/compose functions for data transformation
- Use Proxy for dynamic object behavior
- Include performance optimizations

**Example:**

```javascript
// Pipe function for data transformation
const pipe =
  (...functions) =>
  (initialValue) =>
    functions.reduce((acc, fn) => fn(acc), initialValue);

// Compose functions for complex transformations
const processProjectData = pipe(
  extractHighPriorityTasks,
  groupByTeam,
  calculateTeamWorkload,
  formatForDisplay
);

// Proxy for dynamic object behavior
function createSmartTask(taskData) {
  return new Proxy(taskData, {
    get(target, property) {
      // Your implementation - dynamic property access
    },
    set(target, property, value) {
      // Your implementation - validation and logging
    },
  });
}

// Advanced array operations
function analyzeTaskDistribution(tasks) {
  // Use flatMap, grouping, and statistical calculations
}
```

---

## 🎯 **Bonus Challenges** (+5 points each)

### **Bonus 1: Generator Functions & Iterators**

Implement custom iterators and generator functions for task processing.

```javascript
function* taskGenerator(tasks) {
  // Yield tasks based on priority and dependencies
}

class TaskIterator {
  // Custom iterator implementation
}
```

### **Bonus 2: Symbol Usage & Metaprogramming**

Use Symbols for private properties and implement metaprogramming patterns.

```javascript
// Use Symbol.iterator, Symbol.toPrimitive, etc.
// Implement reflection and dynamic behavior
```

### **Bonus 3: WeakMap/WeakSet for Memory Management**

Implement caching and relationship management using WeakMap/WeakSet.

```javascript
// Efficient caching without memory leaks
// Object relationship tracking
```

### **Bonus 4: Custom Error Classes & Error Handling**

Create sophisticated error handling with custom error types.

```javascript
class TaskValidationError extends Error {
  // Custom error with context and recovery suggestions
}
```

---

## 💡 **JavaScript Concepts Covered**

- **Closures**: Private variables, function factories, memoization
- **Prototypes**: Inheritance chains, prototype manipulation
- **Classes**: ES6 classes, private fields, static methods, mixins
- **Destructuring**: Deep destructuring, defaults, renaming
- **Spread/Rest**: Parameter handling, object/array manipulation
- **Modules**: IIFE, revealing module pattern, namespaces
- **Higher-Order Functions**: Currying, composition, pipe/compose
- **Proxy**: Dynamic object behavior, metaprogramming
- **WeakMap/WeakSet**: Memory-efficient private data
- **Generators**: Custom iterators, lazy evaluation
- **Symbols**: Unique properties, well-known symbols
- **Advanced Arrays**: flatMap, reduce, complex transformations

---

## 🚀 **Getting Started**

1. Create a new file: `daily-challenges/2025/august/day06-advanced-patterns.js`
2. Copy the sample data into your file
3. Implement each section step by step
4. Test thoroughly with provided examples

### **Function Templates**

```javascript
// Sample Data (copy from above)
const projectData = {
  /* ... */
};

// ==========================================
// TASK 1: Advanced Function Patterns
// ==========================================

function createTaskFilter(tasks) {
  // Private state using closure
  let currentTasks = [...tasks];
  let filters = [];
  const cache = new Map();

  return {
    byPriority(...priorities) {
      // Your implementation
      // Return this for chaining
      return this;
    },

    byTeam(teamId) {
      // Your implementation
      return this;
    },

    byTags(tags) {
      // Your implementation
      return this;
    },

    byEstimate(min, max = Infinity) {
      // Your implementation
      return this;
    },

    cached() {
      // Enable memoization
      return this;
    },

    reset() {
      // Reset all filters
      return this;
    },

    execute() {
      // Apply all filters and return results
      // Use cache if enabled
    },
  };
}

// ==========================================
// TASK 2: Classes & Prototypes
// ==========================================

class ProjectEntity {
  #createdAt;
  #id;

  constructor(id) {
    this.#id = id;
    this.#createdAt = new Date();
  }

  get id() {
    return this.#id;
  }
  get age() {
    return Date.now() - this.#createdAt;
  }

  getDescription() {
    throw new Error("Must implement getDescription()");
  }
}

// Mixin implementation
const AuditMixin = {
  logAction(action) {
    // Your implementation
  },

  getAuditTrail() {
    // Your implementation
  },
};

class Task extends ProjectEntity {
  #priority;
  #assignedMembers;

  constructor(id, title, teamId) {
    super(id);
    // Your implementation
  }

  // Private method
  #validatePriority(priority) {
    // Your implementation
  }

  // Static method
  static fromJSON(json) {
    // Your implementation
  }

  // Getter/Setter
  get priority() {
    return this.#priority;
  }
  set priority(value) {
    // Your implementation with validation
  }

  // Override abstract method
  getDescription() {
    // Your implementation
  }

  // Public methods
  assignMember(member) {
    // Your implementation
  }

  updatePriority(priority) {
    // Your implementation
  }
}

// Apply mixin
Object.assign(Task.prototype, AuditMixin);

// ==========================================
// TASK 3: Destructuring & Spread/Rest
// ==========================================

function analyzeProject({
  teams: projectTeams = [],
  tasks: projectTasks = [],
  settings: {
    workingHoursPerDay: dailyHours = 8,
    priorities: priorityConfig = {},
    currencies: { USD: usdRate = 1, ...otherCurrencies } = {},
  } = {},
  ...additionalData
}) {
  // Your implementation
  // Return comprehensive analysis
}

function mergeTeamData(baseTeam, ...updates) {
  // Your implementation using spread operator
}

function extractTaskFields(tasks, ...fieldNames) {
  // Your implementation using destructuring
}

// ==========================================
// TASK 4: Module Pattern
// ==========================================

const TaskManager = (function () {
  const privateData = new WeakMap();

  // Private functions
  function validateTask(task) {
    // Your implementation
  }

  function calculateMetrics(tasks) {
    // Your implementation
  }

  // Public API
  return {
    createTask(taskData) {
      // Your implementation
    },

    getTaskMetrics() {
      // Your implementation
    },

    filters: {
      byPriority(priority) {
        // Your implementation
      },
      byTeam(teamId) {
        // Your implementation
      },
    },

    utils: {
      exportData() {
        // Your implementation
      },
      importData(data) {
        // Your implementation
      },
    },
  };
})();

// ==========================================
// TASK 5: Advanced Manipulation
// ==========================================

const pipe =
  (...functions) =>
  (initialValue) =>
    functions.reduce((acc, fn) => fn(acc), initialValue);

function extractHighPriorityTasks(data) {
  // Your implementation
}

function groupByTeam(tasks) {
  // Your implementation
}

function calculateTeamWorkload(groupedTasks) {
  // Your implementation
}

function formatForDisplay(data) {
  // Your implementation
}

function createSmartTask(taskData) {
  return new Proxy(taskData, {
    get(target, property) {
      // Your implementation
    },
    set(target, property, value) {
      // Your implementation
    },
  });
}

function analyzeTaskDistribution(tasks) {
  // Your implementation using advanced array methods
}

// ==========================================
// TESTING
// ==========================================

console.log("=== Task 1: Function Patterns ===");
const taskFilter = createTaskFilter(projectData.tasks);
console.log(taskFilter.byPriority("high").byTeam(1).execute());

console.log("\n=== Task 2: Classes & Inheritance ===");
const task = new Task(101, "Build Login", 1);
task.assignMember("Alice");
task.priority = "high";
console.log(task.getDescription());
console.log(task.getAuditTrail());

console.log("\n=== Task 3: Destructuring ===");
console.log(analyzeProject(projectData));

console.log("\n=== Task 4: Module Pattern ===");
const newTask = TaskManager.createTask({
  title: "New Feature",
  priority: "high",
});
console.log(TaskManager.getTaskMetrics());

console.log("\n=== Task 5: Advanced Manipulation ===");
const processedData = pipe(
  extractHighPriorityTasks,
  groupByTeam,
  calculateTeamWorkload,
  formatForDisplay
)(projectData);
console.log(processedData);

const smartTask = createSmartTask({ title: "Smart Task", priority: "medium" });
console.log(smartTask.title); // Should trigger Proxy get
```

---

## ✅ **Expected Outputs**

### **Task 1 - Chained Filtering:**

```javascript
[
  {
    id: 101,
    title: "Build Login Page",
    teamId: 1,
    priority: "high",
    estimatedHours: 16,
  },
];
```

### **Task 2 - Class Inheritance:**

```javascript
"Task #101: Build Login Page (Priority: high, Team: 1)"[
  ({ action: "assigned Alice", timestamp: 1691234567890 },
  { action: "priority changed to high", timestamp: 1691234568901 })
];
```

### **Task 4 - Module Usage:**

```javascript
{
  totalTasks: 4,
  averageEstimate: 23,
  priorityDistribution: { high: 2, critical: 1, medium: 1 },
  teamWorkload: { 1: 16, 2: 56, 3: 20 }
}
```

---

## 🔍 **Hints**

<details>
<summary>Click to see hints if you're stuck</summary>

**Task 1 - Closures & Currying**:

```javascript
// Use closure to maintain state between method calls
// Return 'this' for method chaining
// Use Map for memoization: cache.set(filterKey, result)
```

**Task 2 - Classes & Prototypes**:

```javascript
// Private fields: #fieldName
// Static methods: static methodName() {}
// Mixins: Object.assign(Target.prototype, Mixin)
// Super calls: super.methodName()
```

**Task 3 - Destructuring**:

```javascript
// Deep destructuring: { a: { b: { c = defaultValue } } }
// Rest with destructuring: { first, ...rest }
// Dynamic destructuring: Object.entries() with map
```

**Task 4 - Module Pattern**:

```javascript
// IIFE: (function() { /* private scope */ return publicAPI; })()
// WeakMap for private data: privateData.set(instance, data)
// Namespace objects for organization
```

**Task 5 - Advanced Patterns**:

```javascript
// Pipe: functions.reduce((acc, fn) => fn(acc), initial)
// Proxy handlers: get(target, prop), set(target, prop, value)
// flatMap for nested array operations
```

</details>

---

## 🎓 **Learning Objectives**

By completing this challenge, you will:

- ✅ Master advanced closure and higher-order function patterns
- ✅ Understand prototypal inheritance and ES6 classes deeply
- ✅ Learn complex destructuring and spread/rest patterns
- ✅ Implement module patterns and namespace management
- ✅ Use Proxy for metaprogramming and dynamic behavior
- ✅ Apply WeakMap/WeakSet for memory-efficient programming
- ✅ Create sophisticated data transformation pipelines

---

## 📈 **Scoring**

- **Task 1**: 20 points (Function patterns & closures)
- **Task 2**: 25 points (Classes & inheritance)
- **Task 3**: 20 points (Destructuring & spread/rest)
- **Task 4**: 20 points (Module patterns)
- **Task 5**: 15 points (Advanced manipulation)
- **Bonus**: +20 points possible

**Total Possible**: 120 points

---

## 🌟 **Success Criteria**

- ✅ Proper use of closures for private state
- ✅ Correct implementation of class inheritance
- ✅ Advanced destructuring with error handling
- ✅ Clean module pattern with proper encapsulation
- ✅ Efficient use of Proxy and advanced array methods
- ✅ Memory-efficient code using WeakMap/WeakSet

---

## 🔄 **Real-World Applications**

This challenge teaches skills used in:

- **Framework Development**: Building libraries and frameworks
- **Enterprise Applications**: Large-scale application architecture
- **Performance Optimization**: Memory management and efficient algorithms
- **API Design**: Creating clean, extensible interfaces
- **Code Organization**: Module systems and namespace management

---

**Happy Coding! 🎉**

_Today we're diving into the advanced JavaScript patterns that separate junior from senior developers. Master these concepts and you'll be ready for any complex JavaScript challenge!_

---

**Tomorrow's Preview**: We'll explore **Browser APIs & DOM Manipulation** with modern web features! 🌐
